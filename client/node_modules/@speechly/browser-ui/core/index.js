/**
 * Error to be thrown when the device does not support audioContext.
 * @public
 */
var AudioSourceState;
(function (AudioSourceState) {
    AudioSourceState["NoAudioConsent"] = "NoAudioConsent";
    AudioSourceState["NoBrowserSupport"] = "NoBrowserSupport";
    AudioSourceState["Stopped"] = "Stopped";
    AudioSourceState["Starting"] = "Starting";
    AudioSourceState["Started"] = "Started";
})(AudioSourceState || (AudioSourceState = {}));

/**
 * Known WebSocket response types.
 * @internal
 */
var WebsocketResponseType;
(function (WebsocketResponseType) {
    WebsocketResponseType["Started"] = "started";
    WebsocketResponseType["Stopped"] = "stopped";
    WebsocketResponseType["SegmentEnd"] = "segment_end";
    WebsocketResponseType["Transcript"] = "transcript";
    WebsocketResponseType["Entity"] = "entity";
    WebsocketResponseType["Intent"] = "intent";
    WebsocketResponseType["TentativeTranscript"] = "tentative_transcript";
    WebsocketResponseType["TentativeEntities"] = "tentative_entities";
    WebsocketResponseType["TentativeIntent"] = "tentative_intent";
})(WebsocketResponseType || (WebsocketResponseType = {}));
/**
 * Messages from worker to controller
 * @internal
 */
var WorkerSignal;
(function (WorkerSignal) {
    WorkerSignal["Opened"] = "WEBSOCKET_OPEN";
    WorkerSignal["Closed"] = "WEBSOCKET_CLOSED";
    WorkerSignal["AudioProcessorReady"] = "SOURCE_SAMPLE_RATE_SET_SUCCESS";
    WorkerSignal["VadSignalHigh"] = "VadSignalHigh";
    WorkerSignal["VadSignalLow"] = "VadSignalLow";
    WorkerSignal["RequestContextStart"] = "RequestContextStart";
})(WorkerSignal || (WorkerSignal = {}));
/**
 * Messages from controller to worker
 * @internal
 */
var ControllerSignal;
(function (ControllerSignal) {
    ControllerSignal["connect"] = "connect";
    ControllerSignal["initAudioProcessor"] = "initAudioProcessor";
    ControllerSignal["adjustAudioProcessor"] = "adjustAudioProcessor";
    ControllerSignal["SET_SHARED_ARRAY_BUFFERS"] = "SET_SHARED_ARRAY_BUFFERS";
    ControllerSignal["CLOSE"] = "CLOSE";
    ControllerSignal["START_CONTEXT"] = "START_CONTEXT";
    ControllerSignal["SWITCH_CONTEXT"] = "SWITCH_CONTEXT";
    ControllerSignal["STOP_CONTEXT"] = "STOP_CONTEXT";
    ControllerSignal["AUDIO"] = "AUDIO";
    ControllerSignal["startStream"] = "startStream";
    ControllerSignal["stopStream"] = "stopStream";
    ControllerSignal["setContextOptions"] = "setContextOptions";
})(ControllerSignal || (ControllerSignal = {}));
/**
 * All possible states of a Speechly API client. Failed state is non-recoverable.
 * It is also possible to use arithmetics for state comparison, e.g. `if (state < speechly.ClientState.Disconnected)`,
 * to react to non-recoverable states.
 * @public
 */
var DecoderState;
(function (DecoderState) {
    DecoderState[DecoderState["Failed"] = 0] = "Failed";
    DecoderState[DecoderState["Disconnected"] = 1] = "Disconnected";
    DecoderState[DecoderState["Connected"] = 2] = "Connected";
    DecoderState[DecoderState["Active"] = 3] = "Active";
})(DecoderState || (DecoderState = {}));
// TODO: generate this from the enum.
new Map([
    [DecoderState.Failed, 'Failed'],
    [DecoderState.Disconnected, 'Disconnected'],
    [DecoderState.Connected, 'Connected'],
    [DecoderState.Active, 'Active'],
]);

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var base64 = {exports: {}};

/*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */

(function (module, exports) {
(function(root) {

	// Detect free variables `exports`.
	var freeExports = exports;

	// Detect free variable `module`.
	var freeModule = module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code, and use
	// it as `root`.
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var InvalidCharacterError = function(message) {
		this.message = message;
	};
	InvalidCharacterError.prototype = new Error;
	InvalidCharacterError.prototype.name = 'InvalidCharacterError';

	var error = function(message) {
		// Note: the error messages used throughout this file match those used by
		// the native `atob`/`btoa` implementation in Chromium.
		throw new InvalidCharacterError(message);
	};

	var TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	// http://whatwg.org/html/common-microsyntaxes.html#space-character
	var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g;

	// `decode` is designed to be fully compatible with `atob` as described in the
	// HTML Standard. http://whatwg.org/html/webappapis.html#dom-windowbase64-atob
	// The optimized base64-decoding algorithm used is based on @atk’s excellent
	// implementation. https://gist.github.com/atk/1020396
	var decode = function(input) {
		input = String(input)
			.replace(REGEX_SPACE_CHARACTERS, '');
		var length = input.length;
		if (length % 4 == 0) {
			input = input.replace(/==?$/, '');
			length = input.length;
		}
		if (
			length % 4 == 1 ||
			// http://whatwg.org/C#alphanumeric-ascii-characters
			/[^+a-zA-Z0-9/]/.test(input)
		) {
			error(
				'Invalid character: the string to be decoded is not correctly encoded.'
			);
		}
		var bitCounter = 0;
		var bitStorage;
		var buffer;
		var output = '';
		var position = -1;
		while (++position < length) {
			buffer = TABLE.indexOf(input.charAt(position));
			bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;
			// Unless this is the first of a group of 4 characters…
			if (bitCounter++ % 4) {
				// …convert the first 8 bits to a single ASCII character.
				output += String.fromCharCode(
					0xFF & bitStorage >> (-2 * bitCounter & 6)
				);
			}
		}
		return output;
	};

	// `encode` is designed to be fully compatible with `btoa` as described in the
	// HTML Standard: http://whatwg.org/html/webappapis.html#dom-windowbase64-btoa
	var encode = function(input) {
		input = String(input);
		if (/[^\0-\xFF]/.test(input)) {
			// Note: no need to special-case astral symbols here, as surrogates are
			// matched, and the input is supposed to only contain ASCII anyway.
			error(
				'The string to be encoded contains characters outside of the ' +
				'Latin1 range.'
			);
		}
		var padding = input.length % 3;
		var output = '';
		var position = -1;
		var a;
		var b;
		var c;
		var buffer;
		// Make sure any padding is handled outside of the loop.
		var length = input.length - padding;

		while (++position < length) {
			// Read three bytes, i.e. 24 bits.
			a = input.charCodeAt(position) << 16;
			b = input.charCodeAt(++position) << 8;
			c = input.charCodeAt(++position);
			buffer = a + b + c;
			// Turn the 24 bits into four chunks of 6 bits each, and append the
			// matching character for each of them to the output.
			output += (
				TABLE.charAt(buffer >> 18 & 0x3F) +
				TABLE.charAt(buffer >> 12 & 0x3F) +
				TABLE.charAt(buffer >> 6 & 0x3F) +
				TABLE.charAt(buffer & 0x3F)
			);
		}

		if (padding == 2) {
			a = input.charCodeAt(position) << 8;
			b = input.charCodeAt(++position);
			buffer = a + b;
			output += (
				TABLE.charAt(buffer >> 10) +
				TABLE.charAt((buffer >> 4) & 0x3F) +
				TABLE.charAt((buffer << 2) & 0x3F) +
				'='
			);
		} else if (padding == 1) {
			buffer = input.charCodeAt(position);
			output += (
				TABLE.charAt(buffer >> 2) +
				TABLE.charAt((buffer << 4) & 0x3F) +
				'=='
			);
		}

		return output;
	};

	var base64 = {
		'encode': encode,
		'decode': decode,
		'version': '0.1.0'
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = base64;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (var key in base64) {
				base64.hasOwnProperty(key) && (freeExports[key] = base64[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.base64 = base64;
	}

}(commonjsGlobal));
}(base64, base64.exports));

var LocalStorageKeys;
(function (LocalStorageKeys) {
    LocalStorageKeys["SpeechlyFirstConnect"] = "SpeechlyFirstConnect";
})(LocalStorageKeys || (LocalStorageKeys = {}));
var MessageType;
(function (MessageType) {
    MessageType["speechlypoweron"] = "speechlypoweron";
    MessageType["holdstart"] = "holdstart";
    MessageType["holdend"] = "holdend";
    MessageType["speechstate"] = "speechstate";
    MessageType["audiosourcestate"] = "audiosourcestate";
    MessageType["speechsegment"] = "speechsegment";
    MessageType["speechhandled"] = "speechhandled";
    MessageType["showhint"] = "showhint";
    MessageType["transcriptdrawerhint"] = "hint";
    MessageType["speechlyintroready"] = "speechlyintroready";
    MessageType["speechlyintroclosed"] = "speechlyintroclosed";
    MessageType["startcontext"] = "startcontext";
    MessageType["stopcontext"] = "stopcontext";
    MessageType["requeststartmicrophone"] = "requeststartmicrophone";
})(MessageType || (MessageType = {}));
var Icon;
(function (Icon) {
    Icon["Mic"] = "mic";
    Icon["MicActive"] = "micactive";
    Icon["Error"] = "error";
    Icon["Denied"] = "denied";
})(Icon || (Icon = {}));
var Behaviour;
(function (Behaviour) {
    Behaviour["Hold"] = "hold";
    Behaviour["Click"] = "click";
    Behaviour["Noninteractive"] = "noninteractive";
})(Behaviour || (Behaviour = {}));
var Effect;
(function (Effect) {
    Effect["None"] = "none";
    Effect["Connecting"] = "connecting";
    Effect["Busy"] = "busy";
})(Effect || (Effect = {}));
var TriggerFx;
(function (TriggerFx) {
    TriggerFx["None"] = "none";
    TriggerFx["Whirl"] = "whirl";
})(TriggerFx || (TriggerFx = {}));
const clientStateToAppearance = {
    [DecoderState.Disconnected]: { icon: "mic", behaviour: "click", effect: "none", triggerFx: "whirl" },
    [DecoderState.Connected]: { icon: "mic", behaviour: "hold", effect: "none", triggerFx: "whirl" },
    [DecoderState.Active]: { icon: "micactive", behaviour: "hold", effect: "none" },
    [DecoderState.Failed]: { icon: "error", behaviour: "click", effect: "none" },
    [AudioSourceState.NoBrowserSupport]: { icon: "error", behaviour: "click", effect: "none" },
    [AudioSourceState.NoAudioConsent]: { icon: "denied", behaviour: "click", effect: "none" },
};

export { AudioSourceState, Behaviour, DecoderState, Effect, Icon, LocalStorageKeys, MessageType, TriggerFx, clientStateToAppearance };
//# sourceMappingURL=index.js.map
